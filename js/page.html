<html><head><script>
var canvas, ctx, output, scroll;
var added_poly_point, moved_object, started_new_poly, added_agent, add_goal, remove_goal, cpp_progress, set_goal;
var serialize, deserialize, go_to_frame, change_size, update_goal
var grass_pattern, rock_pattern
var world_width, world_height
var needDraw = true
var inq = false

var WORLD_FACTOR = 4

// first multiply, then move by offset
var S2H_XOFFSET = 0
var S2H_YOFFSET = 0
var S2H_SCALE = 5

// referenced in javascript calls from c++
var COLOR_AGENT = 'rgb(255,50,50)'
var COLOR_POINT_GOAL = '#a555ff'
var COLOR_ATTACK_GOAL = '#a40017'
var RADIUS_GOAL = 2
var RADIUS_POLYPOINT = 1

ObjSelType = {
    NONE: 0,
    SINGLE: 1,
    MULTI: 2
}
ObjType = {
    POLYPOINT: 0, AGENT: 1, GOAL: 2
}

function init() {
    canvas = document.getElementById("canvas")
    ctx = canvas.getContext("2d")
    output = document.getElementById("output")
    scroll = document.getElementById("scroll")

    if (typeof qactions !== 'undefined') {
        qactions.cpp_start()
        for (k in qactions) {
            window[k.substring(0, k.indexOf('('))] = qactions[k]
        }
        inq = true
        Pointer_stringify = function(a) { return a }
    }
    else { // emscripten
        Module.ccall('cpp_start', null);
        added_poly_point = Module.cwrap('added_poly_point', null, ['number', 'number']);
        moved_object = Module.cwrap('moved_object', null, ['number', 'number', 'number']);
        started_new_poly = Module.cwrap('started_new_poly', null)
        added_agent = Module.cwrap('added_agent', null, ['number', 'number', 'number', 'number'])
        add_goal = Module.cwrap('add_goal', 'number', ['number', 'number', 'number', 'number'])
        remove_goal = Module.cwrap('remove_goal', null, ['number'])
        set_goal = Module.cwrap('set_goal', null, ['number', 'number'])
        cpp_progress = Module.cwrap('cpp_progress', 'boolean', ['number'])
        serialize = Module.cwrap('serialize', 'string')
        deserialize = Module.cwrap('deserialize', null, ['string'])
        go_to_frame = Module.cwrap('go_to_frame', null, ['number'])
        change_size = Module.cwrap('change_size', null, ['number', 'number'])
        update_goal = Module.cwrap('update_goal', null, ['number', 'number', 'number'])
    }
    
    canvas_place.onmousedown = canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;
    canvas_place.ondblclick = canvas.ondblclick = handleDblClick;
    canvas_place.onclick = canvas.onclick = handleClick;
    canvas_place.onwheel = canvas.onwheel = handleWheel
    document.onwheel = function () {
        if (!event.ctrlKey)
            return true
        return false;
    } // disable zoom so it wont be distorted
    
    resize();
    scrollPos = WORLD_FACTOR/2 - 0.5 // center, minus half the length of the bar
    canvas_cont.scrollLeft = canvas_cont.clientWidth*scrollPos; // 4->1.5  3->0.33  2->0.5
    canvas_cont.scrollTop = canvas_cont.clientHeight*scrollPos; 
    zoom_scroll.min = -(100 - 100 / WORLD_FACTOR)

    //var centerY = Math.round(canvas_cont.clientHeight * WORLD_FACTOR / 200 * 0.5) * 200
    //var centerX = Math.round(canvas_cont.clientWidth * WORLD_FACTOR / 200 * 0.5) * 200
    //var landExt = Math.round(canvas_cont.clientHeight * WORLD_FACTOR / 200 * 0.4) * 200
    //var ay = centerY - landExt, ax = centerX - landExt, by = centerY + landExt, bx = centerX + landExt
    scene_edit.value = "p,\nv,-200,-200,\nv,200,-200,\nv,200,200,\nv,-200,200,"
    //out(scene_edit.value)

    sceneEditChange()
    readScene()

    grass_img.onload = function () {
        if (!grass_pattern)
            grass_pattern = ctx.createPattern(grass_img, "repeat")
        needDraw = true
    }
    grass_img.src = "data:image/svg+xml;base64," + btoa(grass_cont.innerHTML)
    grass_img.onload() // on chrome it loads immediately so make it faster

    rock_img.onload = function () {
        if (!rock_pattern)
            rock_pattern = ctx.createPattern(rock_img, "repeat")
        needDraw = true
    }
    rock_img.src = "data:image/svg+xml;base64," + btoa(rock_cont.innerHTML)
    rock_img.onload()

    showTri.checked = true

    progress();
}

function Transform() {
  this.reset()
}
Transform.prototype.reset = function() {
  this.m = [1,0,0,1,0,0];
};
Transform.prototype.translate = function(x, y) {
  this.m[4] += this.m[0] * x + this.m[2] * y;
  this.m[5] += this.m[1] * x + this.m[3] * y;
};
Transform.prototype.scale = function(sx, sy) {
  this.m[0] *= sx; this.m[1] *= sx;
  this.m[2] *= sy; this.m[3] *= sy;
};
Transform.prototype.invert = function() {
  var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
  var m0 = this.m[3] * d, m1 = -this.m[1] * d;
  var m2 = -this.m[2] * d, m3 = this.m[0] * d;
  var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
  var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
  var nt = new Transform()
  nt.m[0] = m0; nt.m[1] = m1; nt.m[2] = m2;
  nt.m[3] = m3; nt.m[4] = m4; nt.m[5] = m5;
  return nt
};
Transform.prototype.transformPoint = function(px, py) {
  var x = px, y = py;
  px = x * this.m[0] + y * this.m[2] + this.m[4];
  py = x * this.m[1] + y * this.m[3] + this.m[5];
  return {x:px, y:py};
};

var drawCircles = {} // zOrder -> {ptr -> objects}
var drawTriangles = {}
var circles = {} // ptr -> object
var triangles = {}

var pressedObject = null; // object that is currently pressed down
var pressedStart = null; // offset x,y from the center of the selection
// offset from the center of the object at the moment of mouse down so that the first move would not be jerky
var mouseDownOffset = {x:0, y:0} ;
var addingPoly = false;
var addingAgent = false;
var selectSquare = null; // x1, y1, x2, y2, isActive
var multiSelected = []; // agents that were multi selected
var activeGoals = {}; // ptr -> true
var selectedGoal = null;
var isPlaying = true;
//var dt = new Transform()

function getXY(event) {
    var dt = getTransform()
    var inv = dt.invert()    
    //return {x: event.clientX - canvas.offsetLeft + canvas_cont.scrollLeft,
    //        y: event.clientY - canvas.offsetTop + canvas_cont.scrollTop }
    var p = inv.transformPoint(event.clientX - canvas.offsetLeft,
                              event.clientY - canvas.offsetTop)
    p.x -= S2H_XOFFSET
    p.x /= S2H_SCALE
    p.y -= S2H_YOFFSET
    p.y /= S2H_SCALE
    return p                          
}

function zoomValue() {
    return 1 + ((zoom_scroll.value) / 100.0)
}

function handleMouseDown(event) {
    var c = getXY(event);
    var x = c.x, y = c.y;
    needDraw = true

    var reversedZ = Object.keys(drawCircles).reverse()
    for (zi in reversedZ) {
        var z = reversedZ[zi]
        for (p in drawCircles[z]) {
            var o = drawCircles[z][p];
            if (o.isInside(x, y)) {
                pressedObject = o;
                mouseDownOffset.x = pressedObject.x - x
                mouseDownOffset.y = pressedObject.y - y
                pressedStart = {x:x, y:y}
                return true;
            }            
        }
    }

    if (addingPoly) {
        added_poly_point(x, y)
        readScene()
        return true;
    }
    if (addingAgent) {
        added_agent(x, y, parseInt(agentSize.value), -1)
        readScene()
        return true;
    }
    if (!selectSquare) {
        selectSquare = {x1:x, y1:y, x2:x, y2:y}
        return true;
    }
    
    return true // prevent cursor change
}

function handleWheel(event) {
    if (!event.ctrlKey)
        return true
    //out("w=" + event.wheelDelta)
    pointZoom(event.wheelDelta, event)
    needDraw = true
    return false
}

function handleClick(event) {
}

function clearSelGoal() {
    if (selectedGoal != null)
        selectedGoal.isSelected = false;
    selectedGoal = null
}

function clearMultiSel() {
    multiSelected = []
    for(i in circles) {
        circles[i].isSelected = false;
    }
}

function handleDblClick(event) {
    clearMultiSel()
    return false;
}

function selSquareBig() {
    return selectSquare.width > 10 && selectSquare.height > 10
}
function pressedMoveLittle(x, y) {
    if (pressedStart == null)
        return true;
    return Math.abs(pressedStart.x - x) <= 5 && Math.abs(pressedStart.y - y) <= 5
}

function readAgentRadiusFrom(a) {
    agentSize.value = a.radius;
}

function handleMouseUp(event) {
    var c = getXY(event);
    var x = c.x, y = c.y;
    needDraw = true

    if (selectSquare && !selectSquare.isActive &&  multiSelected.length > 0) {
        setGoal(x, y, multiSelected);
        readScene()
    }
    else if ((!selectSquare || !selSquareBig()) && pressedObject != null && pressedObject.selType != ObjSelType.NONE && pressedMoveLittle(x, y)) {
        clearMultiSel()
        clearSelGoal()
        if (pressedObject.objType == ObjType.AGENT) {
            multiSelected = [pressedObject]
            readAgentRadiusFrom(pressedObject);
        }
        if (pressedObject.objType == ObjType.GOAL) {
            goalRadius.value = pressedObject.secondRadius
            var isPoint = pressedObject.color == COLOR_POINT_GOAL // sort of hack, detect its type by the color
            goalPoint.checked = isPoint
            goalAttack.checked = !isPoint
            selectedGoal = pressedObject
        }
        pressedObject.isSelected = true
    }
    
    pressedObject = null
    selectSquare = null;
    return true;
}
function handleMouseMove(event) {
    if (event.movementX == 0 && event.movementY == 0)
        return true;
    var c = getXY(event);
    var x = c.x, y = c.y;

    if (selectSquare) {
        needDraw = true
        selectSquare.x2 = x;
        selectSquare.y2 = y;
        selectSquare.xmin = Math.min(selectSquare.x1, selectSquare.x2);
        selectSquare.ymin = Math.min(selectSquare.y1, selectSquare.y2);
        selectSquare.width = Math.abs(selectSquare.x1 - selectSquare.x2);
        selectSquare.height = Math.abs(selectSquare.y1 - selectSquare.y2)

        if (selSquareBig()) {
            clearMultiSel()
            clearSelGoal()

            //out("sq= " + selectSquare.x1 + " " + selectSquare.y1 + " " + selectSquare.x2 + " " + selectSquare.y2)
            for(i in circles) {
                if (circles[i].isInRect(selectSquare)) {
                    selectSquare.isActive = true;
                    multiSelected.push(circles[i])
                    circles[i].isSelected = true;
                }
                else 
                    circles[i].isSelected = false;
            }
            if (multiSelected.length > 0)
                readAgentRadiusFrom(multiSelected[0])
        }
    }

    if (pressedObject) {
        needDraw = true
        pressedObject.x = x + mouseDownOffset.x;
        pressedObject.y = y + mouseDownOffset.y;
        
        moved_object(pressedObject.ptr, pressedObject.x, pressedObject.y)
        readScene()
    }

    return true;
}

function out(s) {
    //output.innerHTML += s + "<br>"
    console.log(s);
}

/*
function clear_circles() {
    circles = {};
    needDraw = true
}
*/

function remove_circle(ptr) {
    //out("remove " + ptr.toString(16));
    delete drawCircles[circles[ptr].zOrder][ptr]
    delete circles[ptr];
    needDraw = true
}

function remove_triangle(ptr) {
    //out("remove " + ptr.toString(16));
    delete drawTriangles[triangles[ptr].zOrder][ptr]
    delete triangles[ptr];
    needDraw = true
}


function setGoal(x, y, selAgents) {
    var goalPtr = add_goal(x, y, parseFloat(goalRadius.value), goalAttack.checked ? 1:0) // will do add_circle
    activeGoals[goalPtr] = true
    for(i in selAgents) {
        selAgents[i].goalPtr = goalPtr
        set_goal(selAgents[i].ptr, goalPtr);
    }
    var usedGoals = {}
    for(i in circles) {
        if (circles[i].goalPtr)
            usedGoals[circles[i].goalPtr] = true
    }
    for(i in activeGoals) {
        if (!(i in usedGoals)) {
            remove_goal(i);
            delete activeGoals[i];
        }
    }
}

function Circle(x, y, radius, color, selType, objType, secondRadius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.color = color;
    this.selType = selType //multiSel = multiSel;
    this.objType = objType
    this.secondRadius = secondRadius
    this.isSelected = false;
    this.goalPtr = null;
    this.makeDCoord()
}
Circle.prototype.makeDCoord = function () {
    this.dx = this.x * S2H_SCALE + S2H_XOFFSET;
    this.dy = this.y * S2H_SCALE + S2H_YOFFSET;
    this.dradius = this.radius * S2H_SCALE
    this.dsecondRadius = (this.secondRadius != null) ? (this.secondRadius * S2H_SCALE) : null
}
Circle.prototype.draw1 = function() {
    if (this.isSelected) {
        ctx.beginPath();
        ctx.arc(this.dx, this.dy, this.dradius + 3, 0, 2 * Math.PI, false);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgb(80,80,255)";
        ctx.stroke();
    }
}
Circle.prototype.draw2 = function() {
    if (this.isSelected) {
        ctx.beginPath();
        ctx.arc(this.dx, this.dy, this.dradius + 2, 0, 2 * Math.PI, false);
        ctx.fillStyle = "#ffffff";
        ctx.fill()
    }
}
Circle.prototype.draw3 = function() {
    ctx.beginPath();
    ctx.arc(this.dx, this.dy, this.dradius, 0, 2 * Math.PI, false);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.lineWidth = 0.5;
    ctx.strokeStyle = '#000000';
    ctx.stroke();

    if (this.dsecondRadius != null) {
        ctx.beginPath();
        ctx.arc(this.dx, this.dy, this.dsecondRadius, 0, 2 * Math.PI, false)
        ctx.lineWidth = 2;
        ctx.setLineDash([5])
        ctx.strokeStyle = "#679dff"
        ctx.stroke()
        ctx.setLineDash([])
    }
}


Circle.prototype.isInside = function(x, y) {
    return (x >= this.x - this.radius && x <= this.x + this.radius 
         && y >= this.y - this.radius && y <= this.y + this.radius);
}
Circle.prototype.isInRect = function(rect) {
    if (this.selType != ObjSelType.MULTI)
        return false;
    return (this.x >= rect.xmin && this.x <= rect.xmin + rect.width &&
            this.y >= rect.ymin && this.y <= rect.ymin + rect.height) 
}

function add_circle(ptr, zOrder, x, y, radius, color, objSelType, objType, secondRadius) {
    var obj = new Circle(x, y, radius, color, objSelType, objType, secondRadius)
    obj.ptr = ptr;
    obj.zOrder = zOrder;
    circles[ptr] = obj;
    if (!(zOrder in drawCircles))
        drawCircles[zOrder] = []
    drawCircles[zOrder][ptr] = obj;
    needDraw = true
}

function Triangle(ax, ay, bx, by, cx, cy, color) {
    // the real coordinates
    this.ax = ax; this.ay = ay;
    this.bx = bx; this.by = by;
    this.cx = cx; this.cy = cy;
    this.color = color
    this.makeDCoord()
}
Triangle.prototype.makeDCoord = function () {
    // the drawing coordinates
    this.dax = this.ax * S2H_SCALE + S2H_XOFFSET; this.day = this.ay * S2H_SCALE + S2H_YOFFSET;
    this.dbx = this.bx * S2H_SCALE + S2H_XOFFSET; this.dby = this.by * S2H_SCALE + S2H_YOFFSET;
    this.dcx = this.cx * S2H_SCALE + S2H_XOFFSET; this.dcy = this.cy * S2H_SCALE + S2H_YOFFSET;
}
Triangle.prototype.draw1 = function() {
    ctx.beginPath();
    ctx.moveTo(this.dax, this.day);
    ctx.lineTo(this.dbx, this.dby);
    ctx.lineTo(this.dcx, this.dcy);
    ctx.lineTo(this.dax, this.day);
    ctx.fillStyle = showTex.checked ? grass_pattern : "#71fe7b";  // this.color;

    ctx.lineWidth = 0;
    ctx.strokeStyle = 'white'
    ctx.fill()

    // if we don't erase the line the underlying fill shows between triangles
    ctx.lineWidth = showTri.checked ? 0.5 : 2;
    ctx.strokeStyle = showTri.checked ? '#428549' : ctx.fillStyle;
    ctx.stroke()

}

Triangle.prototype.isInside = function(x, y) {
    return false;
}
Triangle.prototype.isInRect = function(rect) {
    return false;
}

function add_tri(ptr, zOrder, ax, ay, bx, by, cx, cy) {
    var obj = new Triangle(ax, ay, bx, by, cx, cy, "#b8ffbf")
    obj.ptr = ptr;
    obj.zOrder = zOrder;
    triangles[ptr] = obj;
    if (!(zOrder in drawTriangles))
        drawTriangles[zOrder] = []
    drawTriangles[zOrder][ptr] = obj;
    needDraw = true
}

// feedback from c++
function move_circle(ptr, x, y) {
    o = circles[ptr];
    if (o.x == x && o.y == y)
        return
    o.x = x;
    o.y = y;
    o.makeDCoord()
    needDraw = true
}
function changed_size(ptr, r) {
    o = circles[ptr]
    if (o.radius == r)
        return
    o.radius = r
    o.makeDCoord();
    needDraw = true
}
function updated_goal(ptr, r, color) {
    o = circles[ptr];
    if (o.secondRadius == r && o.color == color)
        return
    o.secondRadius = r
    o.color = color
    o.makeDCoord()
    needDraw = true
}

function getTransform() {
    var t = new Transform()
    var z = zoomValue()
    t.translate(-canvas_cont.scrollLeft, -canvas_cont.scrollTop)
    t.scale(z, z)
    return t
}



function draw() {
    //ctx.drawImage(grass_img, 10, 10)
    //return

    ctx.setTransform(1, 0, 0, 1, 0, 0)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var dt = getTransform()
    ctx.setTransform(dt.m[0], dt.m[1], dt.m[2], dt.m[3], dt.m[4], dt.m[5]);

    ctx.fillStyle = showTex.checked ? rock_pattern : "#983600"
    ctx.fillRect(0, 0, world_width, world_height);

    //ctx.translate(S2H_XOFFSET, S2H_YOFFSET)
    //ctx.scale(S2H_SCALE, S2H_SCALE);

    for (z in drawTriangles) {
        for (p in drawTriangles[z]) {
            drawTriangles[z][p].draw1();
        }
    }
    for (z in drawCircles) {
        for (p in drawCircles[z]) {
            drawCircles[z][p].draw1();
        }
        for (p in drawCircles[z]) {
            drawCircles[z][p].draw2();
        }
        for (p in drawCircles[z]) {
            drawCircles[z][p].draw3();
        }        
    }
    
    if (selectSquare) {
        ctx.fillStyle = "rgba(0,0,70,0.2)"
        var x1 = selectSquare.xmin * S2H_SCALE + S2H_XOFFSET, y1 = selectSquare.ymin * S2H_SCALE + S2H_YOFFSET
        var w = selectSquare.width * S2H_SCALE, h = selectSquare.height * S2H_SCALE
        ctx.fillRect(x1, y1, w, h);
        ctx.setLineDash([5])
        ctx.strokeRect(x1, y1, w, h);
        ctx.setLineDash([])
    }

  /*  for (i in polyData) {
        var d = polyData[i]
        if (d[0] == 'v') {
            ctx.lineTo(d[1], d[2])
        }
    }
    ctx.strokeStyle = "#fff";
    ctx.stroke();*/
}

function progress() {
    if (isPlaying) {
        cpp_progress(0.4)
        needDraw = true
    }
    if (needDraw)
        draw();
    needDraw = false

    window.requestAnimationFrame(progress)
}

var polyData = []

function readScene() {
    var str = serialize()
    if (str[str.length-1] == '\n')
        str = str.substring(0,str.length-1)

    //var jsonStr = "[[" + str.replace(/v,/g, "],['v',").replace(/p,/g, "],['p',") + "]]"
    //polyData = eval(jsonStr);

    str = str.replace(/\n/g, '<br>')
    if (str == "")
        str = "-";
    scene_def.innerHTML = str
}

function triggerPolyline() {
    addingPoly = !addingPoly;
    if (addingAgent && addingPoly) {
        triggerAgent();
        checkboxAgent.checked = false
    }
    
    var label = document.getElementById("polyLabel")
    /*if (addingPoly)
        label.innerHTML = "End Polyline"
    else
        label.innerHTML = "Start Polyline"
        */
    started_new_poly();    
}

function triggerAgent() {
    addingAgent = !addingAgent;
    if (addingAgent && addingPoly) {
        triggerPolyline();
        checkboxPoly.checked = false
    }
}

function adjustPlaceSize(s) {
    world_width = canvas_cont.clientWidth * WORLD_FACTOR 
    world_height = canvas_cont.clientHeight * WORLD_FACTOR 
    canvas_place.style.width = world_width * s;
    canvas_place.style.height = world_height * s;
}

function resize() {
    canvas_cont.style.width = window.innerWidth - 150 - 8*2;
    //canvas_cont.style.height = window.innerHeight - 30 - 8*2;
    canvas.style.width = canvas.width = canvas_cont.clientWidth
    canvas.style.height = canvas.height = canvas_cont.clientHeight
    
   // but_rel.style.height = window.innerHeight - 16
    scene_def.style.maxHeight = window.innerHeight - 200
    frame_ctrl.style.width = canvas_cont.clientWidth
    frame_scroll.style.width = canvas_cont.clientWidth - 40 - 45 - 4; // 2 margin in each side
    
    var s = zoomValue()
    adjustPlaceSize(s)

    S2H_XOFFSET = world_width * 0.5 // 0,0 should be in the center
    S2H_YOFFSET = world_height * 0.5
    for(var ci in circles)
        circles[ci].makeDCoord()
    for(var ti in triangles)
        triangles[ci].makeDCoord()    
        
    out("sz=" + canvas_cont.clientWidth + " " + canvas_cont.clientHeight)
}

function playstop() {
    isPlaying = !isPlaying
    //play_but.value = isPlaying ? "Stop" : "Play"
    svg_play.style.visibility = isPlaying ? "hidden" : "visible"
    svg_pause.style.visibility = isPlaying ? "visible" : "hidden"
}

var startx = 0, starty = 0, starts = 0
function zoomStart(event) {
    startx = canvas_cont.scrollLeft 
    starty = canvas_cont.scrollTop 
    starts = zoomValue()
    //out("bars=" + xbarpos + " " + ybarpos)
}

function zoomChanged() {
    var w = canvas_cont.clientWidth*0.5
    var h = canvas_cont.clientHeight*0.5

    var s = zoomValue()
    adjustPlaceSize(s)
    
    canvas_cont.scrollLeft = (startx + w)/starts*s - w
    canvas_cont.scrollTop = (starty + h)/starts*s - h
    
    out("center1=" + ((startx + w)/starts) + " " + ((starty + h)/starts))
    
}

function pointZoom(delta, event) {
    var starts = zoomValue()
    var startx = canvas_cont.scrollLeft 
    var starty = canvas_cont.scrollTop 
    
    zoom_scroll.value = parseInt(zoom_scroll.value) + delta * 0.06
        
//    var w = canvas_cont.clientWidth*0.5
//    var h = canvas_cont.clientHeight*0.5    
    var w = event.clientX
    var h = event.clientY
    
    var s = zoomValue()
    adjustPlaceSize(s)
    
    canvas_cont.scrollLeft = (startx + w)/starts*s - w
    canvas_cont.scrollTop = (starty + h)/starts*s - h    
    
}

function sceneTextClick() {
    scene_edit.style.visibility = 'visible'
    scene_edit.style.height = scene_def.clientHeight + 8;
    scene_edit.value = scene_def.innerHTML.replace(/<br>/g,'\n');
    scene_edit.focus()
}
function sceneEditBlur() {
    scene_edit.style.visibility = 'hidden'
}

function sceneEditChange() {
    deserialize(scene_edit.value)
    readScene();
}

function set_max_frame(v) {
    frame_scroll.max = v
    frame_scroll.value = v
    frame_num.innerHTML = frame_scroll.value
}

function frameChange() {
    frame_num.innerHTML = frame_scroll.value
    if (isPlaying)
        playstop()
    go_to_frame(frame_scroll.value)
}

function agentSizeChange() {
    for (i in multiSelected) {
        change_size(multiSelected[i].ptr, parseInt(agentSize.value))
        readScene();
    }
}

function triggerShowTri() {
}
function triggerShowTex() {
}
function canvasScroll() {
    needDraw = true
}
function triggerGoalType(which) {
    if (which == 1) {
        if (!goalAttack.checked)
            goalAttack.checked = true // pressed again the same one, no change
        else
            goalPoint.checked = false
    }
    else {
        if (!goalPoint.checked)
            goalPoint.checked = true
        else
            goalAttack.checked = false
    }

    if (selectedGoal == null)
        return;
    update_goal(selectedGoal.ptr, -1, which)
    readScene();
}

function goalRadiusChange() {
    if (selectedGoal == null)
        return;
    update_goal(selectedGoal.ptr, parseInt(goalRadius.value), -1)
}

</script>
<script src="js_main.js"></script>
<style>
body { /* disable selection so the double click will not select */
   -webkit-touch-callout: none;
   -webkit-user-select: none;
   -khtml-user-select: none;
   -moz-user-select: none;
   -ms-user-select: none;
   user-select: none;
   margin:0;
   background: #333333;
}
#canvas {
    position: absolute;
    background: #fff;
    left: 8px;
    top: 8px;
}
#canvas_cont {
    position: absolute;
    overflow: scroll;
    top: 0;
    left: 0;
    bottom: 30px;
    margin: 8px;
    margin-bottom: 0;
}
#canvas_place {
    width: 2000px;
    height: 2000px;
}
#but_ctrl {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 150px;
    background: #cbcfff;
    margin-top: 8px;
    margin-bottom: 8px;
}
#frame_ctrl {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 30px;
}
#zoom_scroll {
    position: absolute;
    left: 8px;
    top: 140px;
    height:30px;
    width: 132px;
    //-webkit-appearance: slider-vertical;
    writing-mode: bt-lr;
}
#scene_def {
    position: absolute;
    bottom: 0px;
    left: 0;
    font-family: monospace;
    font-size: 10;
    width: 147px;
    margin-left: 2px;
    overflow: hidden;
    
   -webkit-touch-callout: text;
   -webkit-user-select: text;
   -khtml-user-select: text;
   -moz-user-select: text;
   -ms-user-select: text;
   user-select: text;   
}
#scene_edit {
    position: absolute;
    bottom: 0px;
    left: 0;
    font-family: monospace;
    font-size: 10;
    width: 148px;
    margin:0;
       
    white-space: pre;
    word-wrap: normal;
    overflow-x: hidden;
    overflow-y: auto;
    
   -webkit-touch-callout: text;
   -webkit-user-select: text;
   -khtml-user-select: text;
   -moz-user-select: text;
   -ms-user-select: text;
    user-select: text;    

}
    
#frame_scroll {
    position: absolute;
    width: 700px;
    left: 45px;
    right: 30px;
    height: 26px;
    margin: 2px;
    filter: url(#svg_filter);
}
#play_but {
    position: absolute;
    width: 28px;
    height: 26px;
    margin: 2px;
    margin-left: 8px;
    border-radius: 5px;
}
#frame_num {
    position: absolute;
    width: 36px;
    height: 26px;
    right: 0;
    margin: 2px;
    text-align: center;
    color: #fff;
    vertical-align: middle;
    line-height: 26px;
}

#play_but:hover {
  filter: url(#svg_inglow);
}

/* ---------------- side buttons http://www.mattboldt.com/demos/social-buttons/ */
.sc-btn {
  -webkit-appearance: button;
  display: inline-block;
  position: absolute;

  font-family: "Helvetica Neue", "Helvetica", sans-serif;

  text-shadow: rgba(0, 0, 0, 0.3) 0px -0.1em 0px;
  border-radius: 0.4em;

  box-shadow: inset rgba(0, 0, 0, 0.1) 0px -0.15em 0px, inset rgba(255, 255, 255, 0.2) 0px 0.15em 0px, rgba(0, 0, 0, 0.3) 0px 0.1em 0.3em;
  text-align: center;
  cursor: pointer;
  overflow: hidden; 
  
  color: #222;
  text-shadow: rgba(255, 255, 255, 0.4) 0 0.1em 0;
  background-color: #ebebeb;
  background-image: linear-gradient(to bottom, white, #ebebeb);   
  
  width: 140px;
  height: 25px;
  line-height: 25px;
}

.sc-btn:hover {
  color: #222;
  background-color: #d2d2d2;
  background-image: linear-gradient(to bottom, white, #d2d2d2);
  background-color: #fdfdfd;   
}

.sc-btn:active {
    box-shadow: rgba(255, 255, 255, 0.2) 0 0.1em 0, inset rgba(0, 0, 0, 0.3) 0px 0.25em 1em; 
    color: #fff;
    background-color: #dfdfdf;
    background-image: linear-gradient(to bottom, #30b3ee, #108ac1); 
}
.sc-btn:checked {
  color: #fff;
  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #30b3ee, #108ac1); 
}


#checkboxPoly {
    top: 8px;
    left: 2px;
}
#checkboxPoly:before {
  content: "Start Polyline";
}
#checkboxPoly:checked:before {
  content: "End Polyline";
}

#checkboxAgent {
    width: 120px;
    top: 50px;
    left: 12px;
}
#checkboxAgent:before {
  content: "Add Agents";
}

#agentSize {
    position: absolute;
    top: 90px;
    left: 80px;
    width: 55px;
}
#agentSizeLabel {
    position: absolute;
    top: 90px;
    left: 22px;
}
.frame {
    position: absolute;
    border: 2px solid #777;
    left: 8px;
    width: 132;
}
#agentsFrame {
    top: 45px;
    height: 80px;
}
#showTri {
    position: absolute;
    top: 171px;
    left: 8px;
    width: 15px;
    height: 15px;
}
#showTriLabel {
    position: absolute;
    top: 171px;
    left: 31px;
}
#showTex {
    position: absolute;
    top: 190px;
    left: 8px;
    width: 15px;
    height: 15px;
}
#showTexLabel {
    position: absolute;
    top: 190px;
    left: 31px;
}
#goalFrame {
    top: 220px;
    height: 80px;
}
#goalFrameText {
    position: absolute;
    top: 212px;
    left: 20px;
    background: #cbcfff;
}
#goalRadius {
    position: absolute;
    top: 233px;
    left: 80px;
    width: 55px;
}
#goalRadiusLabel {
    position: absolute;
    top: 233px;
    left: 22px;
}
#goalPoint {
    top: 260px;
    left: 12px;
    width: 55px;
}
#goalPoint:before {
  content: "Point";
}
#goalAttack {
    top: 260px;
    left: 75px;
    width: 55px;
}
#goalAttack:before {
  content: "Attack";
}
</style>
</head>

<body onload="init()" onresize="resize()">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2231125-4', 'auto');
  ga('send', 'pageview');
</script>

  <canvas id="canvas" width="200" height="200"></canvas>
  <div id="canvas_cont" onscroll="canvasScroll()">
    <div id="canvas_place"></div>
  </div>

  <div id="but_ctrl"><div id="but_rel" style="position:relative; width:100%; height:100%">
      <input id="checkboxPoly" class="sc-btn" type="checkbox" onclick="triggerPolyline()"/>
      <div id="agentsFrame" class="frame"></div>
      <input id="checkboxAgent" class="sc-btn" type="checkbox" onclick="triggerAgent()"/>
      <input id="agentSize" type="number" value="3" min="1" max="100" oninput="agentSizeChange()"><span id="agentSizeLabel" for="agentSize">Radius:</span>

      <input id="zoom_scroll" type="range" name="zoom" min="-75" max="200" value="0" oninput="zoomChanged()" onmousedown="zoomStart()"/> 
      <input id="showTri" type="checkbox" onclick="triggerShowTri()" /><label id="showTriLabel" for="showTri">Triangulation</label>
      <input id="showTex" type="checkbox" onclick="triggerShowTex()" /><label id="showTexLabel" for="showTex">Textures</label>

      <div id="goalFrame" class="frame"></div><div id="goalFrameText">&nbsp;Goal&nbsp;</div>
      <input id="goalRadius" type="number" value="20" min="1" max="100" oninput="goalRadiusChange()"><span id="goalRadiusLabel" for="goalRadius">Radius:</span>
      <input id="goalPoint" class="sc-btn" type="checkbox" checked="true" onclick="triggerGoalType(0)"/>
      <input id="goalAttack" class="sc-btn" type="checkbox" onclick="triggerGoalType(1)"/>

      <div id="scene_def" onclick="sceneTextClick()"></div>
      <textarea id="scene_edit" style="visibility:hidden;" onblur="sceneEditBlur()" oninput="sceneEditChange()"></textarea>
      
  </div></div>
  
  <div id="frame_ctrl"><div id="frame_rel" style="position:relative; width:100%; height:100%">
     <!-- <input id="play_but" type="button" value="Stop" onclick="playstop()"/> -->
    <svg id="play_but" xmlns="http://www.w3.org/2000/svg" version="1.1"  viewBox="0 0 120 121" height="28px" width="28px" onclick="playstop()">
      <defs
         id="defs3115">
        <filter color-interpolation-filters="sRGB" id="svg_inglow">
          <feGaussianBlur stdDeviation="5" result="result8" />
          <feComposite in2="result8" result="result6" in="SourceGraphic" operator="in" />
          <feComposite in2="result6" operator="in" result="result11" /> 
          <feFlood result="result10" in="result11" flood-opacity="1" flood-color="#007eff" />
          <feBlend in2="result10" mode="normal" in="result11" result="result12" />
          <feComposite in2="SourceGraphic" result="result2" operator="in" in="result12" />
        </filter>
      </defs>
      <path style="fill:#ffffff;" d="m 116.30127,60.31374 c 0,64.67211 5.10064,59.46589 -58.259907,59.46589 -63.3605542,0 -58.25991572,5.20622 -58.25991572,-59.46589 0,-64.6721207 -5.10063848,-59.46588817 58.25991572,-59.46588817 63.360547,0 58.259907,-5.20623253 58.259907,59.46588817 z"/>
      <path id="svg_play" style="visibility:hidden;" d="m 16.098088,59.366021 c 0,54.754259 -5.341711,52.024439 48.229915,24.647306 53.571617,-27.377124 53.571617,-21.917488 0,-49.294612 C 10.756377,7.3415825 16.098088,4.6117648 16.098088,59.366021 z"/>
      <g id="svg_pause" style="visibility:visible;">
          <path style="fill:#000000" d="m 49.990939,100.8508 c -1.384296,4.00567 -11.938566,3.75061 -13.896261,3.75061 -1.957693,0 -12.511963,0.25506 -13.896261,-3.75061 -1.384296,-4.00568 -1.296149,-34.546086 -1.296149,-40.210972 0,-5.664886 -0.08815,-36.205293 1.296149,-40.210973 1.384298,-4.005678 11.938568,-3.750607 13.896261,-3.750607 1.957692,0 12.511965,-0.255072 13.896261,3.750607 1.384298,4.00568 1.296149,34.546085 1.296149,40.210971 0,5.664885 0.08815,36.205294 -1.296149,40.210974 z"/>
          <path style="fill:#000000" d="m 95.725861,100.83689 c -1.384296,4.00567 -11.938566,3.7506 -13.896261,3.7506 -1.957693,0 -12.511963,0.25507 -13.896261,-3.7506 -1.384296,-4.005685 -1.296149,-34.546091 -1.296149,-40.210977 0,-5.664886 -0.08815,-36.205293 1.296149,-40.210973 1.384298,-4.005678 11.938568,-3.750607 13.896261,-3.750607 1.957692,0 12.511965,-0.255072 13.896261,3.750607 1.384298,4.00568 1.296149,34.546085 1.296149,40.210971 0,5.664885 0.08815,36.205294 -1.296149,40.210979 z"/>
      </g>
    </svg>

      <input id="frame_scroll" type="range" name="points" min="0" max="100" value="0" oninput="frameChange()"/>
      <div id="frame_num">0</div>
  </div>

    <div id="grass_cont" style="display:none;"><svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" version="1.1">
      <defs>
        <filter id="filter_grass2" x="-0.15" width="1.3" y="-0.15" height="1.3" color-interpolation-filters="sRGB">
          <feTurbulence numOctaves="5" baseFrequency="0.05" type="fractalNoise" stitchTiles="stitch" result="result0"/>
          <feComposite in="result0" in2="SourceGraphic" k1="1" k2="0.5" k3="1" operator="arithmetic" result="result6"/>
          <feComposite in="result6" in2="result0" operator="in" result="result91" />
          <feComposite in="SourceGraphic" in2="result91" k1="1.5" operator="arithmetic" />
        </filter>
      </defs>
      <rect style="fill:#ffffff;" width="400" height="400" x="0" y="0"/>
      <rect style="fill:#8ffe8f;filter:url(#filter_grass2)" width="400" height="400" x="0" y="0"/>
    </svg></div> <!--#beffbe-->
    <img id="grass_img" style="display:none;"/>

    <div id="rock_cont" style="display:none;"><svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" version="1.1">
       <defs>
        <filter id="filter_grass3" x="-0.15" width="1.3" y="-0.15" height="1.3" color-interpolation-filters="sRGB">
          <feTurbulence numOctaves="5" baseFrequency="0.015" type="fractalNoise" stitchTiles="stitch" result="result0"/>
          <feComposite in="result0" in2="SourceGraphic" k1="1" k2="0.5" k3="1" operator="arithmetic" result="result6"/>
          <feComposite in="result6" in2="result0" operator="in" result="result91" />
          <feComposite in="SourceGraphic" in2="result91" k1="1.5" operator="arithmetic" />
        </filter>
      </defs>
      <rect style="fill:#774119;" width="400" height="400" x="0" y="0"/>
      <rect style="fill:#512006;filter:url(#filter_grass3)" width="400" height="400" x="0" y="0"/>
    </svg></div>
    <img id="rock_img" style="display:none;"/>


</body>

</html>