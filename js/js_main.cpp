#include <emscripten.h>#include <string>#include <vector>#include <memory>#include "../Vec2.h"#include "../Document.h"using namespace std;// bias the index so that they would be displayed in the proper z order#define Z_POLYPOINT 10#define Z_TRI 0#define Z_AGENT 20#define Z_GOAL 25class NavCtrl;typedef int ptr_t;class Item {public:    Item(NavCtrl* ctrl) : m_ctrl(ctrl)    {}    virtual ~Item() {        EM_ASM_( remove_object($0), this );    }    virtual void setPos(const Vec2& p)     {}    NavCtrl* m_ctrl;};class PolyPointItem : public Item{public:    PolyPointItem(NavCtrl* ctrl, Vertex* v) :Item(ctrl), m_v(v)    {        EM_ASM_( add_circle($0, $1, $2, $3, $4, 'rgb(50,50,50)', false), this, Z_POLYPOINT, m_v->p.x, m_v->p.y, 5);    }    virtual void setPos(const Vec2& p) {        m_v->p = p;        EM_ASM_( move_object($0, $1, $2), this, m_v->p.x, m_v->p.y);    }        Vertex* m_v;};class TriItem  : public Item{public:    TriItem(NavCtrl* ctrl, Triangle* t) :Item(ctrl), m_t(t)    {        const Vec2& a = m_t->v[0]->p;        const Vec2& b = m_t->v[1]->p;        const Vec2& c = m_t->v[2]->p;        //EM_ASM_( out("tri (" + $0 + " " + $1 + ") (" + $2 + " " + $3 + ") (" + $4 + " " + $5 + ")"), a.x, a.y, b.x, b.y, c.x, c.y);        EM_ASM_( add_tri($0, $1, $2, $3, $4, $5, $6, $7), this, Z_TRI, a.x, a.y, b.x, b.y, c.x, c.y);    }    Triangle* m_t;};class AgentItem : public Item{public:    AgentItem(NavCtrl* ctrl, Agent* a) :Item(ctrl), m_a(a)    {        EM_ASM_( add_circle($0, $1, $2, $3, $4, 'rgb(255,50,50)', true), this, Z_AGENT, m_a->m_position.x, m_a->m_position.y, m_a->m_radius);    }    virtual void setPos(const Vec2& p) {        m_a->setPos(p);        updatePos();    }    void updatePos() {        EM_ASM_( move_object($0, $1, $2), this, m_a->m_position.x, m_a->m_position.y);    }    Agent* m_a;};class GoalItem : public Item{public:    GoalItem(NavCtrl* ctrl, Goal* g) :Item(ctrl), m_g(g)    {        EM_ASM_( add_circle($0, $1, $2, $3, $4, 'rgb(165,85,255)', false), this, Z_GOAL, m_g->p.x, m_g->p.y, 7);    }    virtual void setPos(const Vec2& p);    Goal* m_g;};class NavCtrl{public:    void addPoly() {        m_doc.m_mapdef.add();    }    void addPolyPoint(const Vec2& p)     {        auto pv = m_doc.m_mapdef.addToLast(p);        auto i = new PolyPointItem(this, pv);        m_polypointitems.push_back(shared_ptr<PolyPointItem>(i));        updateMesh();    }    void addAgent(const Vec2& p)    {        auto pa = m_doc.addAgent(p, nullptr);        auto i = new AgentItem(this, pa);        m_agentitems.push_back(shared_ptr<AgentItem>(i));    }    GoalItem* addGoal(const Vec2& p)     {        auto pg = m_doc.addGoal(p);        auto i  = new GoalItem(this, pg);        m_goalitems.push_back(shared_ptr<GoalItem>(i));         return i;    }    void removeGoal(GoalItem* g) {        auto it = m_goalitems.begin();        while(it != m_goalitems.end()) {            if (it->get() == g)                it = m_goalitems.erase(it);            else                ++it;        }    }    void setGoal(Agent* a, Goal* g) {        a->m_endGoalPos = g->p;        m_doc.updatePlan(a);    }    void setGoal(AgentItem* a, GoalItem* g) {        setGoal(a->m_a, g->m_g);    }        void progress(float deltaSec) {        m_doc.doStep(deltaSec, true);  //0.25        for(auto& a: m_agentitems) {            a->updatePos();        }    }        void updateMesh();    void readMesh();            vector<shared_ptr<PolyPointItem>> m_polypointitems;    vector<shared_ptr<TriItem>> m_meshitems;    vector<shared_ptr<AgentItem>> m_agentitems;    vector<shared_ptr<GoalItem>> m_goalitems;    Document m_doc;};// depends on NavCtrlvoid GoalItem::setPos(const Vec2& p) {    m_g->p = p;    for(auto* a: m_g->agents)        m_ctrl->setGoal(a, m_g);    EM_ASM_( move_object($0, $1, $2), this, m_g->p.x, m_g->p.y);}void NavCtrl::updateMesh(){    m_doc.runTriangulate();    m_meshitems.clear();    for(auto& tri : m_doc.m_mesh.m_tri) {        auto i = new TriItem(this, &tri);        m_meshitems.push_back(shared_ptr<TriItem>(i));    }}NavCtrl g_ctrl;void cpp_out(const char* s) {    EM_ASM_( out(Pointer_stringify($0)), s);}extern "C" {void cpp_start(){}void started_new_poly() {    g_ctrl.addPoly();}void added_poly_point(int x, int y) {    g_ctrl.addPolyPoint(Vec2(x, y));}void added_agent(int x, int y) {    g_ctrl.addAgent(Vec2(x, y));}void moved_object(ptr_t ptr, int x, int y){    Item* p = (Item*)ptr;    p->setPos(Vec2(x, y));    g_ctrl.updateMesh();}ptr_t add_goal(int x, int y) {    return (ptr_t)g_ctrl.addGoal(Vec2(x, y));}void set_goal(ptr_t agentPtr, ptr_t goalPtr) {    AgentItem* a = (AgentItem*)agentPtr;    GoalItem* g = (GoalItem*)goalPtr;    g_ctrl.setGoal(a, g);}void remove_goal(ptr_t ptr) {    GoalItem* g = (GoalItem*)ptr;    g_ctrl.removeGoal(g);}void cpp_progress(float deltaSec) {    g_ctrl.progress(deltaSec);    }}